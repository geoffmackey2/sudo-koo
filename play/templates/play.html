{% extends 'base.html' %}
{% load static %}

{% block head %}
<link href="{% static 'css/play_styles.css' %}" rel="stylesheet">
{% endblock %}

{% block content %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const game = document.getElementById('game');
    const grid = document.getElementById('game-grid');
    const gridBackground = grid.getElementById('grid-background');
    const cells = grid.getElementsByClassName('cell');
    const gameControls = document.getElementById('game-controls');
    const digitControl = document.getElementById('digit-control');
    const cornerControl = document.getElementById('corner-control');
    const middleControl = document.getElementById('middle-control');
    const colorControl = document.getElementById('color-control');
    const createButton = document.getElementById('create-button');
    const importButton = document.getElementById('import-button');
    const playButton = document.getElementById('play-button');
    const cancelButton = document.getElementById('cancel-button');
    const errorMessage = document.getElementById('error-message');
    const happyMessage = document.getElementById('happy-message');
    const puzzleTitle = document.getElementById('puzzle-title');
    const importDialog = document.getElementById('import-dialog');
    const importDialogCancelButton = document.getElementById('import-cancel');
    const cancelPuzzGenButton = document.getElementById('cancel-puzzle-gen');
    const modes = {
        DIGIT: 'digit',
        CORNER: 'corner',
        MIDDLE: 'middle',
        COLOR: 'color',
        CREATE: 'create'
    }
    const direction = {
        UP: 'up',
        DOWN: 'down',
        LEFT: 'left',
        RIGHT: 'right'
    }
    const colors = {
        1: '#620000',
        2: '#117845',
        3: '#000ACE',
        4: '#670EE5',
        5: '#8A135A',
        6: '#884210',
        7: '#3F2114',
        8: '#141414',
        9: '#525252'
    }
    const cornerMarkOffsets = {
        topLeft: { x: 6, y: 23.5 },
        topMiddle: { x: 32, y: 23.5 },
        topRight: { x: 61, y: 23.5 },
        middleLeft: { x: 6, y: 48 },
        middleMiddle: { x: 32, y: 48 },
        middleRight: { x: 61, y: 48 },
        bottomLeft: { x: 6, y: 72 },
        bottomMiddle: { x: 32, y: 72 },
        bottomRight: { x: 61, y: 72 }
    }
    const cornerPositions = {
        TOP_LEFT: 'topLeft',
        TOP_MIDDLE: 'topMiddle',
        TOP_RIGHT: 'topRight',
        MIDDLE_LEFT: 'middleLeft',
        MIDDLE_MIDDLE: 'middleMiddle',
        MIDDLE_RIGHT: 'middleRight',
        BOTTOM_LEFT: 'bottomLeft',
        BOTTOM_MIDDLE: 'bottomMiddle',
        BOTTOM_RIGHT: 'bottomRight'
    }
    const historyActions = {
        PLACE_DIGIT: 'placedDigits',
        PLACE_CORNER_MARK: 'cornerMarks',
        PLACE_MIDDLE_MARK: 'middleMarks',
        PLACE_COLOR: 'colors',
        CLEAR_CELLS: 'clearCells'
    }
    const errors = {
        INVALID_PUZZLE: 'Sorry, this puzzle isn\'t valid! Double-check your given digits.',
        SERVER_ERROR: 'Sorry, something went wrong! Please try again.'
    }
    const happyMessages = {
        GREAT_JOB: 'Great job. You solved the puzzle!',
        STARTING_TIP: 'Click "create" or "import" to set up a puzzle and start playing!'
    }
    const stepDirection = {
        BACKWARD: 'backward',
        FORWARD: 'forward'
    }
    const boxes = setupBoxes();
    var gameState = [];
    var lastCellSelection;
    var currentMode = modes.DIGIT;
    var previousMode;
    var originalDragTarget;
    var activeGame;
    var puzzleHistory;
    var puzzGenTimeout;

    function setupGame() {
        checkLocalStorage();
        var currentPuzzleTitle = '';
        if(localStorage.getItem('puzzleTitle') != null) {
            currentPuzzleTitle = localStorage.getItem('puzzleTitle');
        }
        puzzleTitle.innerHTML = currentPuzzleTitle;
        
        if(game.dataset.importedPuzzle === 'True' && game.dataset.puzzleImportError != 'True') {
            toggleGeneratingPuzzleMode(true)
            checkPuzzleGenerationStatus();
        } else if(game.dataset.puzzleImportError === 'True') {
            displayErrorMessage(errors.SERVER_ERROR);
        }
        
        setupControls();

        var keyPressed = false;

        document.addEventListener("pointerdown", function (event) {
            if(!importDialog.open) {
                event.preventDefault();
                const pointerX = event.pageX + window.scrollX;
                const pointerY = event.pageY + window.scrollY;
                var dragging = false;
                
                if(!event.shiftKey && !targetIsControlOrBackground(event.target)) {
                    if(event.target.parentElement === lastCellSelection && getSelectedCells().length === 1) {
                        deselectAll(lastCellSelection);
                    } else {
                        deselectAll();
                    }
                }
                for (const cell of cells) {
                    if (checkPointerIntersection({x: pointerX, y: pointerY}, cell)) {
                        if(!isSelected(cell)) {
                            selectCell(cell);
                        } else {
                            deselectCell(cell);
                        }
                    }
                }
                if(!checkPointerIntersection({x: pointerX, y: pointerY}, grid) &&
                !checkPointerIntersection({x: pointerX, y: pointerY}, gameControls)) {
                    deselectAll();
                }

                function makeSelections(event) {
                    if(currentMode != modes.CREATE) {
                        const pointerX = event.pageX + window.scrollX;
                        const pointerY = event.pageY + window.scrollY;

                        if(originalDragTarget === null) {
                            originalDragTarget = event.target;
                        }

                        if(dragging && checkPointerIntersection({x: pointerX, y: pointerY}, grid) && targetIsControlOrBackground(originalDragTarget)) {
                            for(const cell of cells) {
                                if (checkPointerIntersection({x: pointerX, y: pointerY}, cell)) {
                                    deselectAll();
                                    originalDragTarget = false;
                                }
                            }
                        }
                        if(!dragging && !event.shiftKey && !targetIsControlOrBackground(event.target)) {
                            deselectAll();
                        }
                        dragging = true;

                        for (const cell of cells) {
                            if (checkPointerIntersection({x: pointerX, y: pointerY}, cell)) {
                                selectCell(cell);
                            }
                        }
                    }
                }

                document.addEventListener("pointermove", makeSelections);
                document.addEventListener("pointerup", () => {
                    document.removeEventListener("pointermove", makeSelections);
                    dragging = false;
                    originalDragTarget = null;
                });
            }
        });

        document.addEventListener('keydown', function(event) {
            event.preventDefault();
            if(!keyPressed) {
                keyPressed = true;
                var number = 0;
                if(/Digit[1-9]|Numpad[1-9]/.test(event.code)) {
                    number = parseInt(event.code.split(/Digit|Numpad/, 2)[1]);
                }
                if(event.altKey && number === 0) {
                    updateCurrentMode(modes.CORNER);
                    keyPressed = false;
                } else if(event.ctrlKey && number === 0) {
                    if(event.code === 'KeyZ') {
                        if(event.shiftKey) {
                            stepThroughHistory(stepDirection.FORWARD);
                        } else {
                            stepThroughHistory(stepDirection.BACKWARD);
                        }
                    } else {
                        updateCurrentMode(modes.MIDDLE);
                    }
                    keyPressed = false;
                }
                if(number > 0) {
                    switch(currentMode) {
                        case modes.CREATE:
                            placeGivenDigit(number);
                            break;
                        case modes.COLOR:
                            updateSelectedCellsForColor(number, true);
                            break;
                        case modes.DIGIT:
                            placeDigitInSelectedSells(number, true);
                            break;
                        case modes.CORNER:
                            placeCornerMarkInSelectedCells(number, true);
                            break;
                        case modes.MIDDLE:
                            placeMiddleMarkInSelectedCells(number, true);
                            break;
                    }
                    
                }
                if (event.code === 'Backspace') {
                    clearSelectedCells(true);
                }
            }
            switch(event.code) {
                case 'ArrowDown':
                    moveCellSelection(direction.DOWN, event.shiftKey);
                    break;
                case 'ArrowLeft':
                    moveCellSelection(direction.LEFT, event.shiftKey);
                    break;
                case 'ArrowRight':
                    moveCellSelection(direction.RIGHT, event.shiftKey);
                    break;
                case 'ArrowUp':
                    moveCellSelection(direction.UP, event.shiftKey);
                    break;
                case 'PageDown':
                    changeMode(direction.DOWN);
                    break;
                case 'PageUp':
                    changeMode(direction.UP);
                    break;
            }
        });
        
        document.addEventListener('keyup', function(event) {
            if(keyPressed) {
                keyPressed = false;
            }
            if(event.code === 'AltLeft' || 
               event.code === 'AltRight' || 
               event.code === 'ControlLeft' || 
               event.code === 'ControlRight') {
                updateCurrentMode(previousMode);
            }
        });
    }

    function toggleGeneratingPuzzleMode(generating) {
        if(generating) {
            puzzleTitle.innerHTML = 'Generating new puzzle...';
            cancelPuzzGenButton.style.display = 'block';
            createButton.style.opacity = '0.25';
            createButton.style.pointerEvents = 'none';
            importButton.style.opacity = '0.25';
            importButton.style.pointerEvents = 'none';
            digitControl.style.pointerEvents = 'none';
            digitControl.style.opacity = '0.25';
            cornerControl.style.pointerEvents = 'none';
            cornerControl.style.opacity = '0.25';
            middleControl.style.pointerEvents = 'none';
            middleControl.style.opacity = '0.25';
            colorControl.style.pointerEvents = 'none';
            colorControl.style.opacity = '0.25';
            toggleBoardGlow(true);
            clearGrid();
        } else {
            toggleBoardGlow(false);
            puzzleTitle.innerHTML = game.dataset.puzzleTitle;
            cancelPuzzGenButton.style.display = 'none';
            createButton.style.opacity = '1';
            createButton.style.pointerEvents = 'auto';
            importButton.style.opacity = '1';
            importButton.style.pointerEvents = 'auto';
            digitControl.style.pointerEvents = 'auto';
            digitControl.style.opacity = '1';
            cornerControl.style.pointerEvents = 'auto';
            cornerControl.style.opacity = '1';
            middleControl.style.pointerEvents = 'auto';
            middleControl.style.opacity = '1';
            colorControl.style.pointerEvents = 'auto';
            colorControl.style.opacity = '1';
        }
    }

    function toggleBoardGlow(glowOn) {
        var glowTypes = ['a', 'b', 'c', 'd'];
        if(glowOn) {
            var glowType = 0;
            for(const cell of cells) {
                const cellBackground = cell.getElementsByClassName('cell-background')[0];
                cellBackground.classList.add('glowing-cell-'+glowTypes[glowType]);
                glowType++;
                if(glowType === glowTypes.length) {
                    glowType = 0;
                }
            }
        } else {
            for(const cell of cells) {
                const cellBackground = cell.getElementsByClassName('cell-background')[0];
                for(var i = 0; i < glowTypes.length; i++) {
                    cellBackground.classList.remove('glowing-cell-'+glowTypes[i]);
                }
            }
        }
    }

    function checkPuzzleGenerationStatus() {
        const jobID = game.dataset.puzzleJobId;
        fetch('/play/puzzle_status/' + jobID)
            .then(response => response.json())
            .then(data => {
            if (data.status !== 'finished' && data.status !== 'failed') {
                puzzGenTimeout = setTimeout(checkPuzzleGenerationStatus, 300);
            } else if(data.status === 'finished') {
                localStorage.setItem('puzzleData', data.result.split('').join(','));
                localStorage.removeItem('puzzleHistory');
                localStorage.setItem('puzzleTitle', game.dataset.puzzleTitle);
                toggleGeneratingPuzzleMode(false);
                checkLocalStorage();
            } else {
                cancelPuzzleGeneration();
                displayErrorMessage(errors.SERVER_ERROR);
            }
        });
    }

    function cancelPuzzleGeneration() {
        clearTimeout(puzzGenTimeout);
        var puzzleTitleText = localStorage.getItem('puzzleTitle');
        if(puzzleTitleText != null) {
            puzzleTitle.innerHTML = puzzleTitleText;
        } else {
            puzzleTitle.innerHTML = '';
        }
        cancelPuzzGenButton.style.display = 'none';
        toggleBoardGlow(false);
        buildExistingPuzzle();
    }

    function buildExistingPuzzle() {
        const puzzleData = localStorage.getItem('puzzleData');
        if(puzzleData != null) {
            clearGrid();
            activeGame = true;
            gameState = puzzleData.split(',');
            for(var i = 0; i < cells.length; i++) {
                if(gameState[i] != '0') {
                    lastCellSelection = cells[i];
                    placeGivenDigit(gameState[i]);
                }
            }
        }
    }

    function checkLocalStorage() {
        buildExistingPuzzle();
        puzzleHistory = localStorage.getItem('puzzleHistory');
        if(puzzleHistory != null) {
            puzzleHistory = JSON.parse(decryptString(puzzleHistory));
            var lastHistoryIndex = puzzleHistory['lastHistoryIndex'];
            if(lastHistoryIndex > -1) {
                puzzleHistory['lastHistoryIndex'] = -1;
                for(var i = 0; i <= lastHistoryIndex; i++) {
                    stepThroughHistory(stepDirection.FORWARD);
                }
                deselectAll();
            }
        } else {
            puzzleHistory = {
                actions: [],
                lastHistoryIndex: -1
            };
            localStorage.setItem('puzzleHistory', encryptString(JSON.stringify(puzzleHistory)));
        }
    }

    function placeGivenDigit(digit) {
        const cellGivenDigits = lastCellSelection.getElementsByClassName('given-digit');
        const cellBackground = lastCellSelection.getElementsByClassName('cell-background')[0];
        if(cellGivenDigits.length === 0) {
            const givenDigit = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            givenDigit.setAttribute('class', 'given-digit');
            givenDigit.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + 26);
            givenDigit.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + 55.5);
            givenDigit.textContent = String(digit);
            lastCellSelection.appendChild(givenDigit);
        } else {
            if(cellGivenDigits[0].textContent === String(digit)) {
                cellGivenDigits[0].remove();
            } else {
                cellGivenDigits[0].textContent = String(digit);
            }
        }
    }

    function setupControls() {
        digitControl.addEventListener('click', function(event) {
            event.preventDefault();
            updateCurrentMode(modes.DIGIT);
        });

        cornerControl.addEventListener('click', function(event) {
            event.preventDefault();
            updateCurrentMode(modes.CORNER)
        });

        middleControl.addEventListener('click', function(event) {
            event.preventDefault();
            updateCurrentMode(modes.MIDDLE);
        });

        colorControl.addEventListener('click', function(event) {
            event.preventDefault();
            updateCurrentMode(modes.COLOR);
        });

        createButton.addEventListener('click', function(event) {
            event.preventDefault();
            clearGrid();
            updateCurrentMode(modes.CREATE);
        });

        playButton.addEventListener('click', function(event) {
            event.preventDefault();
            var puzzleSetData= [];
            for(var i = 1; i < cells.length + 1; i++) {
                const givenDigits = cells[i-1].getElementsByClassName('given-digit');
                if(givenDigits.length > 0) {
                    puzzleSetData.push(parseInt(givenDigits[0].textContent));
                } else {
                    puzzleSetData.push(0);
                }
            }
            verifyPuzzle(puzzleSetData.join(''));
        });

        cancelButton.addEventListener('click', function(event) {
            event.preventDefault();
            checkLocalStorage();
            exitCreateMode();
        });

        importButton.addEventListener('click', function(event) {
            event.preventDefault();
            importDialog.showModal();
        });

        importDialogCancelButton.addEventListener('click', function(event) {
            importDialog.close();
        });

        cancelPuzzGenButton.addEventListener('click', function(event) {
            toggleGeneratingPuzzleMode(false);
            cancelPuzzleGeneration();
        });
    }

    function exitCreateMode() {
        playButton.style.display = 'none';
        createButton.style.display = 'block';
        cancelButton.style.display = 'none';
        importButton.style.display = 'block'
        digitControl.style.pointerEvents = 'auto';
        digitControl.style.opacity = '1';
        cornerControl.style.pointerEvents = 'auto';
        cornerControl.style.opacity = '1';
        middleControl.style.pointerEvents = 'auto';
        middleControl.style.opacity = '1';
        colorControl.style.pointerEvents = 'auto';
        colorControl.style.opacity = '1';
        puzzleTitle.style.display = 'block';
        if(!activeGame) {
            clearGrid();
        }
        updateCurrentMode(modes.DIGIT);
    }

    async function verifyPuzzle(puzzleSetData) {
        try {
            const csrftoken = "{{ csrf_token }}";
            const response = await fetch('/play/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'text/plain',
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify(puzzleSetData),
                signal: AbortSignal.timeout(3000)
            });
            if(!response.ok) {
                throw new Error('Response status: ${response.status}');
            }
            const verified = await response.text();
            if(verified === 'true') {
                gameState = puzzleSetData.split('');
                localStorage.setItem('puzzleData', gameState);
                localStorage.setItem('puzzleTitle', 'Custom Puzzle');
                puzzleTitle.innerHTML = 'Custom Puzzle';
                localStorage.removeItem('puzzleHistory');
                activeGame = true;
                exitCreateMode();
            } else {
                displayErrorMessage(errors.INVALID_PUZZLE);
            }
        } catch (e) {
            displayErrorMessage(errors.SERVER_ERROR);
            console.error(e);
        }
    }

    function setupBoxes() {
        const boxesSetup = [];
        for(let blockRow = 0; blockRow < 3; blockRow++) {
            for(let blockCol = 0; blockCol < 3; blockCol++) {
                const box = [];
                for(var i = blockRow * 3; i < (blockRow + 1) * 3; i++) {
                    for(var j = blockCol * 3; j < (blockCol + 1) * 3; j++) {
                        box.push((i * 9) + j)
                    }
                }
                boxesSetup.push(box);
            }
        }
        return boxesSetup;
    }

    function displayErrorMessage(message) {
        errorMessage.style.display = 'block';
                errorMessage.style.opacity = 1;
                errorMessage.innerHTML = message;
                setTimeout(function() {
                    errorMessage.style.opacity = 0;
                    setTimeout(function() {
                        errorMessage.style.display = 'none'
                    }, 200);
                }, 3200);
    }

    function displayHappyMessage(message) {
        happyMessage.style.display = 'block';
                happyMessage.style.opacity = 1;
                happyMessage.innerHTML = message;
                setTimeout(function() {
                    happyMessage.style.opacity = 0;
                    setTimeout(function() {
                        happyMessage.style.display = 'none'
                    }, 200);
                }, 3200);
    }

    function clearGrid() {
        for(const cell of cells) {
            if(cell.getElementsByClassName('given-digit').length > 0) {
                cell.getElementsByClassName('given-digit')[0].remove();
            }
            if(cell.getElementsByClassName('placed-digit').length > 0) {
                clearCellDigit(cell);
            }
            if(cell.getElementsByClassName('middle-marks').length > 0) {
                clearCellMiddleMarks(cell);
            }
            if(cell.getElementsByClassName('corner-mark').length > 0) {
                clearCellCornerMarks(cell);
            }
            if(cell.getElementsByClassName('color-segment').length > 0) {
                clearCellColors(cell);
            }
        }
    }

    function targetIsControlOrBackground(target) {
        return target === digitControl ||
               target === cornerControl ||
               target === middleControl ||
               target === colorControl ||
               target === gameControls ||
               target === gridBackground;
    }

    function changeMode(rotateDirection) {
        switch(rotateDirection) {
            case direction.UP:
                switch(currentMode) {
                    case modes.DIGIT:
                        updateCurrentMode(modes.COLOR);
                        break;
                    case modes.CORNER:
                        updateCurrentMode(modes.DIGIT);
                        break;
                    case modes.MIDDLE:
                        updateCurrentMode(modes.CORNER);
                        break;
                    case modes.COLOR:
                        updateCurrentMode(modes.MIDDLE);
                        break;
                }
            break;
            case direction.DOWN:
                switch(currentMode) {
                    case modes.DIGIT:
                        updateCurrentMode(modes.CORNER);
                        break;
                    case modes.CORNER:
                    updateCurrentMode(modes.MIDDLE);
                        break;
                    case modes.MIDDLE:
                    updateCurrentMode(modes.COLOR);
                        break;
                    case modes.COLOR:
                        updateCurrentMode(modes.DIGIT);
                        break;
                }
            break;
        }
    }

    function updateSelectedCellsForColor(color, addToHistory) {
        const selectedCells = getSelectedCells();
        var colorMatchCount = 0;
        var cellsWithoutThisColor = [];
        var selectedCellCount = selectedCells.length;
        for(const colorCheckCell of selectedCells) {
            if(colorCheckCell.getElementsByClassName('given-digit').length === 0) {
                const cellColors = colorCheckCell.getElementsByClassName('color-segment');
                if(cellColors.length === 0) {
                    cellsWithoutThisColor.push(colorCheckCell);
                } else {
                    var colorNotFound = false;
                    for(const cellColor of cellColors) {
                        if(cellColor.getAttribute('fill') === colors[color]) {
                            colorMatchCount++;
                        } else {
                        colorNotFound = true;
                        }
                    }
                    if(colorNotFound) {
                        cellsWithoutThisColor.push(colorCheckCell);
                    }
                }
            } else {
                selectedCellCount--;
            }
        }
        if(colorMatchCount === selectedCellCount) {
            for(const cell of selectedCells) {
                removeCellColor(cell, colors[color]);
            }
        } else {
            for(const cell of cellsWithoutThisColor) {
                addColorToCell(cell, color);
            }
        }
        if(addToHistory) {
            updateHistory(historyActions.PLACE_COLOR, getSelectedCellsConfigurations(color));
        }
    }

    function removeCellColor(cell, color) {
        const cellColors = cell.getElementsByClassName('color-segment');
        var existingCellColors = [];
        for(const colorSegment of cellColors) {
            existingCellColors.push(colorSegment.getAttribute('fill'));
        }
        clearCellColors(cell);
        for(const colorIndex in colors) {
            if(colors[colorIndex] != color && existingCellColors.includes(colors[colorIndex])) {
                addColorToCell(cell, colorIndex);
            }   
        }
    }

    function addColorToCell(cell, color) {
        const cellColors = cell.getElementsByClassName('color-segment');
        const existingNumberOfColors = cellColors.length;
        const cellBackground = cell.getElementsByClassName('cell-background')[0];
        const cellBackgroundXpos = parseFloat(cellBackground.getAttribute('x'));
        const cellBackgroundYpos = parseFloat(cellBackground.getAttribute('y'));
        var dValue;
        var fillValue;

        switch (existingNumberOfColors) {
            case 0:
                const oneColorRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                oneColorRect.setAttribute('class', 'color-segment');
                oneColorRect.setAttribute('x', cellBackgroundXpos + .5);
                oneColorRect.setAttribute('y', cellBackgroundYpos + .5);
                oneColorRect.setAttribute('width', '78');
                oneColorRect.setAttribute('height', '78');
                oneColorRect.setAttribute('fill', colors[color]);
                oneColorRect.setAttribute('opacity', 0.65);
                cellBackground.after(oneColorRect);
                break;
            case 1:
                dValue = 'M'+(cellBackgroundXpos+.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+.5)+' V'+(cellBackgroundYpos+.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[0].getAttribute('fill');
                const segment1 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+.5)+' V'+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+78.5)+' Z';
                fillValue = colors[color];
                const segment2 = newColorSegment(dValue, fillValue);
                clearCellColors(cell);
                cellBackground.after(segment1);
                cellBackground.after(segment2);
                break;
            case 2:
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+17)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[0].getAttribute('fill');
                const segment3 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+17)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+0.5)+' V'+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+17)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[1].getAttribute('fill');
                const segment4 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+17)+' '+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+39.5)+' Z';
                fillValue = colors[color];
                const segment5 = newColorSegment(dValue, fillValue);
                clearCellColors(cell);
                cellBackground.after(segment3);
                cellBackground.after(segment4);
                cellBackground.after(segment5);
                break;
            case 3:
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+39.5)+' V'+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[0].getAttribute('fill');
                const segment6 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+0.5)+' V'+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+39.5)+' V'+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[1].getAttribute('fill');
                const segment7 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+0.5)+' V'+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+39.5)+' V'+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[2].getAttribute('fill');
                const segment8 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+39.5)+' V'+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+39.5)+' Z';
                fillValue = colors[color];
                const segment9 = newColorSegment(dValue, fillValue);
                clearCellColors(cell);
                cellBackground.after(segment6);
                cellBackground.after(segment7);
                cellBackground.after(segment8);
                cellBackground.after(segment9);
                break;
            case 4:
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+62)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[0].getAttribute('fill');
                const segment10 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+0.5)+' V'+(cellBackgroundYpos+68.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+63)+' '+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[1].getAttribute('fill');
                const segment11 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+0.5)+' '+(cellBackgroundYpos+68.5)+' V'+(cellBackgroundYpos+11)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[2].getAttribute('fill');
                const segment12 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+0.5)+' '+(cellBackgroundYpos+11)+' V'+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+62)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[3].getAttribute('fill');
                const segment13 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+39.5)+' L'+(cellBackgroundXpos+62)+' '+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+39.5)+' Z';
                fillValue = colors[color];
                const segment14 = newColorSegment(dValue, fillValue);
                clearCellColors(cell);
                cellBackground.after(segment10);
                cellBackground.after(segment11);
                cellBackground.after(segment12);
                cellBackground.after(segment13);
                cellBackground.after(segment14);
                break;
            case 5:
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+62)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[0].getAttribute('fill');
                const segment15 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+17)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+62)+' '+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[1].getAttribute('fill');
                const segment16 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+17)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+0.5)+' V'+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[2].getAttribute('fill');
                const segment17 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+0.5)+' V'+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+17)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[3].getAttribute('fill');
                const segment18 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+17)+' '+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+62)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[4].getAttribute('fill');
                const segment19 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+62)+' '+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+39.5)+' Z';
                fillValue = colors[color];
                const segment20 = newColorSegment(dValue, fillValue);
                clearCellColors(cell);
                cellBackground.after(segment15);
                cellBackground.after(segment16);
                cellBackground.after(segment17);
                cellBackground.after(segment18);
                cellBackground.after(segment19);
                cellBackground.after(segment20);
                break;
            case 6:
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+70.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[0].getAttribute('fill');
                const segment21 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+70.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+30.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+70.5)+' '+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[1].getAttribute('fill');
                const segment22 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+30.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+0.5)+' V'+(cellBackgroundYpos+58.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+30.5)+' '+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[2].getAttribute('fill');
                const segment23 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+0.5)+' '+(cellBackgroundYpos+58.5)+' V'+(cellBackgroundYpos+20.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[3].getAttribute('fill');
                const segment24 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+0.5)+' '+(cellBackgroundYpos+20.5)+' V'+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+30.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[4].getAttribute('fill');
                const segment25 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+70.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[5].getAttribute('fill');
                const segment26 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+30.5)+' '+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+70.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = colors[color];
                const segment27 = newColorSegment(dValue, fillValue);
                clearCellColors(cell);
                cellBackground.after(segment21);
                cellBackground.after(segment22);
                cellBackground.after(segment23);
                cellBackground.after(segment24);
                cellBackground.after(segment25);
                cellBackground.after(segment26);
                cellBackground.after(segment27);
                break;
            case 7:
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+78.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[0].getAttribute('fill');
                const segment28 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+39.5)+' V'+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[1].getAttribute('fill');
                const segment29 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+0.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' V'+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[2].getAttribute('fill');
                const segment30 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+0.5)+' '+(cellBackgroundYpos+78.5)+' V'+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+39.5)+' L'+(cellBackgroundXpos+0.5)+' '+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[3].getAttribute('fill');
                const segment31 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+0.5)+' V'+(cellBackgroundYpos+0.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[4].getAttribute('fill');
                const segment32 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+0.5)+' '+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+39.5)+' V'+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[5].getAttribute('fill');
                const segment33 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' V'+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+78.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[6].getAttribute('fill');
                const segment34 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+39.5)+' L'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+0.5)+' V'+(cellBackgroundYpos+39.5)+' Z';
                fillValue = colors[color];
                const segment35 = newColorSegment(dValue, fillValue);
                clearCellColors(cell);
                cellBackground.after(segment28);
                cellBackground.after(segment29);
                cellBackground.after(segment30);
                cellBackground.after(segment31);
                cellBackground.after(segment32);
                cellBackground.after(segment33);
                cellBackground.after(segment34);
                cellBackground.after(segment35);
                break;
            case 8:
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+72.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+72.5)+' Z';
                fillValue = cellColors[0].getAttribute('fill');
                const segment36 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+72.5)+' V'+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+46.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+72.5)+' Z';
                fillValue = cellColors[1].getAttribute('fill');
                const segment37 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+46.5)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+17)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+46.5)+' '+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[2].getAttribute('fill');
                const segment38 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+17)+' '+(cellBackgroundYpos+78.5)+' H'+(cellBackgroundXpos+0.5)+' V'+(cellBackgroundYpos+53.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+17)+' '+(cellBackgroundYpos+78.5)+' Z';
                fillValue = cellColors[3].getAttribute('fill');
                const segment39 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+0.5)+' '+(cellBackgroundYpos+53.5)+' V'+(cellBackgroundYpos+25.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[4].getAttribute('fill');
                const segment40 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+0.5)+' '+(cellBackgroundYpos+25.5)+' V'+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+17)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[5].getAttribute('fill');
                const segment41 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+17)+' '+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+46.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' Z';
                fillValue = cellColors[6].getAttribute('fill');
                const segment42 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+6.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+46.5)+' '+(cellBackgroundYpos+0.5)+' H'+(cellBackgroundXpos+78.5)+' V'+(cellBackgroundYpos+6.5)+' Z';
                fillValue = cellColors[7].getAttribute('fill');
                const segment43 = newColorSegment(dValue, fillValue);
                dValue = 'M'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+39.5)+' '+(cellBackgroundYpos+39.5)+' L'+(cellBackgroundXpos+78.5)+' '+(cellBackgroundYpos+6.5)+' V'+(cellBackgroundYpos+39.5)+' Z';
                fillValue = colors[color];
                const segment44 = newColorSegment(dValue, fillValue);
                clearCellColors(cell);
                cellBackground.after(segment36);
                cellBackground.after(segment37);
                cellBackground.after(segment38);
                cellBackground.after(segment39);
                cellBackground.after(segment40);
                cellBackground.after(segment41);
                cellBackground.after(segment42);
                cellBackground.after(segment43);
                cellBackground.after(segment44);
                break;
        }
    }

    function newColorSegment(dValue, fillValue) {
        const colorSegment = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        colorSegment.setAttribute('class', 'color-segment');
        colorSegment.setAttribute('fill', fillValue);
        colorSegment.setAttribute('d', dValue);
        colorSegment.setAttribute('opacity', 0.65);
        return colorSegment;
    }

    function updateCurrentMode(mode) {
        if(currentMode != mode) {
            previousMode = currentMode;
            currentMode = mode;
        }
        updateControls(currentMode);
    }

    function updateControls(mode) {
        for(const control of gameControls.children) {
            control.classList.remove('selected');
        }
        switch(mode) {
            case modes.DIGIT:
                digitControl.classList.add('selected');
                break;
            case modes.CORNER:
                cornerControl.classList.add('selected');
                break;
            case modes.MIDDLE:
                middleControl.classList.add('selected');
                break;
            case modes.COLOR:
                colorControl.classList.add('selected');
                break;
            case modes.CREATE:
                playButton.style.display = 'block';
                cancelButton.style.display = 'block';
                createButton.style.display = 'none';
                importButton.style.display = 'none';
                digitControl.style.pointerEvents = 'none';
                cornerControl.style.pointerEvents = 'none';
                middleControl.style.pointerEvents = 'none';
                colorControl.style.pointerEvents = 'none';
                digitControl.style.opacity = '0.25';
                cornerControl.style.opacity = '0.25'
                middleControl.style.opacity = '0.25';
                colorControl.style.opacity = '0.25'
                puzzleTitle.style.display = 'none';
                break;
        }
    }

    function clearCellColors(cell) {
        const cellColors = cell.getElementsByClassName('color-segment');
        while(cellColors.length > 0) {
            cellColors[0].remove();
        }
    }

    function setCellColorsOpacity(cell, opacity) {
        const cellColors = cell.getElementsByClassName('color-segment');
        for(const cellColor of cellColors) {
            cellColor.setAttribute('opacity', opacity);
        }
    }

    function placeDigitInSelectedSells(digit, addToHistory) {
        if(addToHistory) {
            updateHistory(historyActions.PLACE_DIGIT, getSelectedCellsConfigurations(digit));
        }
        const selectedCells = getSelectedCells();
        for(const cell of selectedCells) {
            const cellGivenDigits = cell.getElementsByClassName('given-digit')
            const cellBackground = cell.getElementsByClassName('cell-background')[0];
            const cellDigits = cell.getElementsByClassName('placed-digit');
            const cellID = parseInt(cell.id.split('-')[1]);
            var cellDigitFoundAndRemoved = false;
            for(const cellDigit of cellDigits) {
                if(cellDigit.textContent === String(digit)) {
                    cellDigit.remove();
                    if(activeGame) {
                        gameState[cellID] = '0';
                        validateGrid();
                    }
                    cellDigitFoundAndRemoved = true;
                }
            }
            if(!cellDigitFoundAndRemoved) {
                if(cellGivenDigits.length === 0) {
                    if(cellDigits.length === 0) {
                        const newCellDigit = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        newCellDigit.setAttribute('class', 'placed-digit');
                        newCellDigit.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + 26);
                        newCellDigit.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + 55.5);
                        newCellDigit.textContent = String(digit);
                        cell.appendChild(newCellDigit);
                    } else {
                        cellDigits[0].textContent = String(digit);
                    }
                    if(activeGame) {
                        gameState[cellID] = String(digit);
                        validateGrid();
                    }
                }
            }
            updateCellConfig(cell);
        }
    }

    function stepThroughHistory(direction) {
        if(puzzleHistory != null) {
            if(direction === stepDirection.FORWARD) {
                puzzleHistory['lastHistoryIndex']++
                if(puzzleHistory['lastHistoryIndex'] > puzzleHistory['actions'].length - 1) {
                    puzzleHistory['lastHistoryIndex'] = puzzleHistory['actions'].length;
                }
                localStorage.setItem('puzzleHistory', encryptString(JSON.stringify(puzzleHistory)));
            }
            if(direction === stepDirection.BACKWARD && puzzleHistory['lastHistoryIndex'] === puzzleHistory['actions'].length) {
                puzzleHistory['lastHistoryIndex']--;
            }
            if(puzzleHistory['lastHistoryIndex'] > -1 && puzzleHistory['lastHistoryIndex'] < puzzleHistory['actions'].length) {
                var lastAction = puzzleHistory['actions'][puzzleHistory['lastHistoryIndex']];
                var selectedCellStrings = lastAction['cells'];
                var selectedCells = [];
                for(const cellString of selectedCellStrings) {
                    const cellJSON = JSON.parse(cellString);
                    selectedCells.push(cellJSON);
                }
                switch(lastAction['action']) {
                    case historyActions.PLACE_CORNER_MARK:
                        for(const cell of selectedCells) {
                            deselectAll();
                            selectCell(getCellByID(cell['cellID']));
                            placeCornerMarkInSelectedCells(cell['newValue'], false);
                        }
                        break;
                    case historyActions.PLACE_MIDDLE_MARK:
                        for(const cell of selectedCells) {
                            deselectAll();
                            selectCell(getCellByID(cell['cellID']));
                            placeMiddleMarkInSelectedCells(cell['newValue'], false);
                        }
                        break;
                    case historyActions.PLACE_COLOR:
                        for(const cell of selectedCells) {
                            deselectAll();
                            selectCell(getCellByID(cell['cellID']));
                            updateSelectedCellsForColor(cell['newValue'], false);
                        }
                        break;
                    case historyActions.PLACE_DIGIT:
                        for(const cell of selectedCells) {
                            deselectAll();
                            selectCell(getCellByID(cell['cellID']));
                            if(direction === stepDirection.BACKWARD) {
                                previousDigit = cell['placedDigits'][0];
                                if(previousDigit != null) {
                                    placeDigitInSelectedSells(cell['placedDigits'][0], false);
                                } else {
                                    clearCellDigit(getCellByID(cell['cellID']));
                                }
                            } else {
                                placeDigitInSelectedSells(cell['newValue'], false);
                            }
                        }
                        break;
                    case historyActions.CLEAR_CELLS:
                        for(const cell of selectedCells) {
                            deselectAll();
                            selectCell(getCellByID(cell['cellID']));
                            if(cell['cornerMarks'].length > 0) {
                                const cellCornerMarks = cell['cornerMarks'].split('');
                                for(const cornerMark of cellCornerMarks) {
                                    placeCornerMarkInSelectedCells(cornerMark, false);
                                }
                            }
                            if(cell['middleMarks'].length > 0) {
                                const cellMiddleMarks = cell['middleMarks'].split('');
                                for(const middleMark of cellMiddleMarks) {
                                    placeMiddleMarkInSelectedCells(middleMark, false);
                                }
                            }
                            if(cell['colors'].length > 0) {
                                const cellColors = cell['colors'].split('');
                                for(const color of cellColors) {
                                    updateSelectedCellsForColor(color, false);
                                }
                            }
                            if(cell['placedDigits'].length > 0) {
                                const placedDigits = cell['placedDigits'].split('');
                                for(const placedDigit of placedDigits) {
                                    placeDigitInSelectedSells(placedDigit, false);
                                }
                            }
                        }
                        break;
                }
                for(const selectedCell of selectedCells) {
                    selectCell(getCellByID(selectedCell['cellID']));
                }
            }
            if(direction === stepDirection.BACKWARD) {
                puzzleHistory['lastHistoryIndex']--;
                if(puzzleHistory['lastHistoryIndex'] < 0) {
                    puzzleHistory['lastHistoryIndex'] = -1;
                    deselectAll();
                }
                localStorage.setItem('puzzleHistory', encryptString(JSON.stringify(puzzleHistory)));
            }
        }
    }

    function updateHistory(action, cellConfigurations) {
        var lastAction = {
            action: action,
            cells: cellConfigurations
        }
        puzzleHistory['actions'].push(lastAction);
        puzzleHistory['lastHistoryIndex'] = puzzleHistory['actions'].length - 1;
        localStorage.setItem('puzzleHistory', encryptString(JSON.stringify(puzzleHistory)));
    }

    function validateGrid() {
        var gridIsValid = true;
        for(const cell of cells) {
            const cellBackground = cell.getElementsByClassName('cell-background')[0]
            cellBackground.classList.remove('conflict');
        }
        // validate box
        for(const box of boxes) {
            var digitsInBox = new Set();
            for(var i = 0; i < box.length; i++) {
                if(gameState[box[i]] != '0') {
                    digitsInBox.add(gameState[box[i]]);
                }
            }
            for(const digit of digitsInBox) {
                var matchingCellsInBox = [];
                for(var i = 0; i < box.length; i++) {
                    if(gameState[box[i]] === digit) {
                        matchingCellsInBox.push(box[i]);
                    }
                }
                if(matchingCellsInBox.length > 1) {
                    for(var i = 0; i < matchingCellsInBox.length; i++) {
                        const cellBackground = getCellByID('cell-'+matchingCellsInBox[i]).getElementsByClassName('cell-background')[0];
                        cellBackground.classList.add('conflict');
                        gridIsValid = false;
                    }
                }
            }
        }
        for(var i = 0; i < gameState.length; i++) {
            if(gameState[i] !== '0') {
                const digit = gameState[i];
                const row = (Math.ceil((i + 1) / 9)) - 1;
                const column = (i - (row * 9)) + 9;
                // validate row
                matchingDigitsInRow = [];
                for(var j = (i - column + 9); j <= (i + (8 - column) + 9); j++) {
                    if(gameState[j] === digit) {
                        matchingDigitsInRow.push(j);
                    }
                }
                if(matchingDigitsInRow.length > 1) {
                    for(var j = 0; j < matchingDigitsInRow.length; j++) {
                        const cellBackground = getCellByID('cell-'+matchingDigitsInRow[j]).getElementsByClassName('cell-background')[0];
                        cellBackground.classList.add('conflict');
                        gridIsValid = false;
                    }
                }
                // validate column
                matchingDigitsInColumn = [];
                for(var j = (i - row * 9); j <= (71+column); j+=9) {
                    if(gameState[j] === digit) {
                        matchingDigitsInColumn.push(j);
                    }
                }
                if(matchingDigitsInColumn.length > 1) {
                    for(var j = 0; j < matchingDigitsInColumn.length; j++) {
                        const cellBackground = getCellByID('cell-'+matchingDigitsInColumn[j]).getElementsByClassName('cell-background')[0];
                        cellBackground.classList.add('conflict');
                        gridIsValid = false;
                    }
                }
            }
        }
        var gridIsComplete = true;
        for(var i = 0; i < gameState.length; i++) {
            if(parseInt(gameState[i]) === 0) {
                gridIsComplete = false;
            }
        }
        if(gridIsValid && gridIsComplete) {
            gameOver();
        }
    }

    function gameOver() {
        displayHappyMessage(happyMessages.GREAT_JOB);
    }

    function placeCornerMarkInSelectedCells(digit, addToHistory) {
        const selectedCells = getSelectedCells();
        for(const cell of selectedCells) {
            const cellPlacedDigits = cell.getElementsByClassName('placed-digit');
            const cellGivenDigits = cell.getElementsByClassName('given-digit');
            var newCornerMark = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            if(cellPlacedDigits.length === 0 && cellGivenDigits.length === 0) {
                const cellBackground = cell.getElementsByClassName('cell-background')[0];
                const cellCornerMarks = cell.getElementsByClassName('corner-mark');
                var markFoundAndRemoved = false;
                for(const cornerMark of cellCornerMarks) {
                    if(cornerMark.textContent === String(digit)) {
                        cornerMark.remove();
                        updateCornerMarks(cell, cornerMark.id);
                        markFoundAndRemoved = true;
                    }
                }
                if(!markFoundAndRemoved) {
                    switch(cellCornerMarks.length) {
                        case 0:
                            newCornerMark.setAttribute('class', 'corner-mark');
                            newCornerMark.setAttribute('id', cornerPositions.TOP_LEFT)
                            newCornerMark.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + cornerMarkOffsets.topLeft.x);
                            newCornerMark.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + cornerMarkOffsets.topLeft.y);
                            newCornerMark.textContent = String(digit);
                            cell.appendChild(newCornerMark);
                            break;
                        case 1:
                            newCornerMark = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newCornerMark.setAttribute('class', 'corner-mark');
                            newCornerMark.setAttribute('id', cornerPositions.TOP_RIGHT)
                            newCornerMark.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + cornerMarkOffsets.topRight.x);
                            newCornerMark.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + cornerMarkOffsets.topRight.y);
                            newCornerMark.textContent = String(digit);
                            cell.appendChild(newCornerMark);
                            break;
                        case 2:
                            newCornerMark = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newCornerMark.setAttribute('class', 'corner-mark');
                            newCornerMark.setAttribute('id', cornerPositions.BOTTOM_LEFT);
                            newCornerMark.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + cornerMarkOffsets.bottomLeft.x);
                            newCornerMark.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + cornerMarkOffsets.bottomLeft.y);
                            newCornerMark.textContent = String(digit);
                            cell.appendChild(newCornerMark);
                            break;
                        case 3:
                            newCornerMark = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newCornerMark.setAttribute('class', 'corner-mark');
                            newCornerMark.setAttribute('id', cornerPositions.BOTTOM_RIGHT)
                            newCornerMark.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + cornerMarkOffsets.bottomRight.x);
                            newCornerMark.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + cornerMarkOffsets.bottomRight.y);
                            newCornerMark.textContent = String(digit);
                            cell.appendChild(newCornerMark);
                            break;
                        case 4:
                            newCornerMark = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newCornerMark.setAttribute('class', 'corner-mark');
                            newCornerMark.setAttribute('id', cornerPositions.MIDDLE_LEFT)
                            newCornerMark.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + cornerMarkOffsets.middleLeft.x);
                            newCornerMark.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + cornerMarkOffsets.middleLeft.y);
                            newCornerMark.textContent = String(digit);
                            cell.appendChild(newCornerMark);
                            break;
                        case 5:
                            newCornerMark = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newCornerMark.setAttribute('class', 'corner-mark');
                            newCornerMark.setAttribute('id', cornerPositions.MIDDLE_RIGHT)
                            newCornerMark.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + cornerMarkOffsets.middleRight.x);
                            newCornerMark.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + cornerMarkOffsets.middleRight.y);
                            newCornerMark.textContent = String(digit);
                            cell.appendChild(newCornerMark);
                            break;
                        case 6:
                            newCornerMark = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newCornerMark.setAttribute('class', 'corner-mark');
                            newCornerMark.setAttribute('id', cornerPositions.TOP_MIDDLE)
                            newCornerMark.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + cornerMarkOffsets.topMiddle.x);
                            newCornerMark.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + cornerMarkOffsets.topMiddle.y);
                            newCornerMark.textContent = String(digit);
                            cell.appendChild(newCornerMark);
                            break;
                        case 7:
                            newCornerMark = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newCornerMark.setAttribute('class', 'corner-mark');
                            newCornerMark.setAttribute('id', cornerPositions.BOTTOM_MIDDLE)
                            newCornerMark.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + cornerMarkOffsets.bottomMiddle.x);
                            newCornerMark.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + cornerMarkOffsets.bottomMiddle.y);
                            newCornerMark.textContent = String(digit);
                            cell.appendChild(newCornerMark);
                            break;
                        case 8:
                            newCornerMark = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            newCornerMark.setAttribute('class', 'corner-mark');
                            newCornerMark.setAttribute('id', cornerPositions.MIDDLE_MIDDLE)
                            newCornerMark.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + cornerMarkOffsets.middleMiddle.x);
                            newCornerMark.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + cornerMarkOffsets.middleMiddle.y);
                            newCornerMark.textContent = String(digit);
                            cell.appendChild(newCornerMark);
                            break;
                    }
                }
            }
        }
        if(addToHistory) {
            updateHistory(historyActions.PLACE_CORNER_MARK, getSelectedCellsConfigurations(digit));
        }
    }

    function placeMiddleMarkInSelectedCells(digit, addToHistory) {
        const selectedCells = getSelectedCells();
        for(const cell of selectedCells) {
            const cellPlacedDigits = cell.getElementsByClassName('placed-digit');
            const cellGivenDigits = cell.getElementsByClassName('given-digit');
            const cellMiddleMarks = cell.getElementsByClassName('middle-marks');
            if(cellPlacedDigits.length === 0 && cellGivenDigits.length === 0) {
                const cellBackground = cell.getElementsByClassName('cell-background')[0];
                if(cellPlacedDigits.length === 0 && cellGivenDigits.length === 0) {
                    if(cellMiddleMarks.length === 0) {
                        const newMiddleMarkContainer = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        newMiddleMarkContainer.setAttribute('class', 'middle-marks');
                        newMiddleMarkContainer.setAttribute('dominant-baseline', 'middle');
                        newMiddleMarkContainer.setAttribute('text-anchor', 'middle');
                        newMiddleMarkContainer.setAttribute('data-count', '0');
                        newMiddleMarkContainer.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + 38.5);
                        newMiddleMarkContainer.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + 41.5);
                        cell.appendChild(newMiddleMarkContainer);
                    }
                    const cellMiddleMarksDigits = cellMiddleMarks[0].getElementsByTagName('tspan');
                    var middleMarkFoundAndRemoved = false;
                    for(const middleMarkDigit of cellMiddleMarksDigits) {
                        if(middleMarkDigit.textContent === String(digit)) {
                            middleMarkDigit.remove();
                            cellMiddleMarks[0].setAttribute('data-count', parseInt(cellMiddleMarks[0].getAttribute('data-count')) - 1);
                            if(parseInt(cellMiddleMarks[0].getAttribute('data-count')) === 0) {
                                cellMiddleMarks[0].remove();
                            }
                            middleMarkFoundAndRemoved = true;
                        }
                    }
                    if(!middleMarkFoundAndRemoved) {
                        const middleMarks = cellMiddleMarks[0].getElementsByTagName('tspan');
                        const middleMarksSortedArray = Array.from(middleMarks).sort(function(a, b) {
                            if(parseInt(a.textContent) < parseInt(b.textContent)) return -1;
                            if(parseInt(a.textContent) > parseInt(b.textContent)) return 1;
                            return 0;
                        });
                        const middleMarkDigit = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                        middleMarkDigit.textContent = String(digit);
                        if(middleMarksSortedArray.length > 0) {
                            for(var i = 0; i < middleMarksSortedArray.length; i++) {
                                if(digit < parseInt(middleMarksSortedArray[i].textContent)) {
                                    for(const middleMark of middleMarks) {
                                        if(middleMark === middleMarksSortedArray[i]) {
                                            middleMark.before(middleMarkDigit);
                                        }
                                    }
                                    break;
                                } else {
                                    cellMiddleMarks[0].appendChild(middleMarkDigit);
                                }
                            }
                        } else {
                            cellMiddleMarks[0].appendChild(middleMarkDigit);
                        }
                        cellMiddleMarks[0].setAttribute('data-count', parseInt(cellMiddleMarks[0].getAttribute('data-count')) + 1);
                    }
                }
                
            }
        }
        if(addToHistory) {
            updateHistory(historyActions.PLACE_MIDDLE_MARK, getSelectedCellsConfigurations(digit));
        }
    }

    function shiftCornerMark(cell, fromPosition, toPosition) {
        const cellBackground = cell.getElementsByClassName('cell-background')[0];
        const cornerMark = getCornerMarkByID(cell, fromPosition);
        cornerMark.setAttribute('id', toPosition);
        cornerMark.setAttribute('x', parseFloat(cellBackground.getAttribute('x')) + cornerMarkOffsets[toPosition].x);
        cornerMark.setAttribute('y', parseFloat(cellBackground.getAttribute('y')) + cornerMarkOffsets[toPosition].y);
    }

    function updateCornerMarks(cell, removedPosition) {
        const cellCornerMarks = cell.getElementsByClassName('corner-mark');
        const cellBackground = cell.getElementsByClassName('cell-background')[0];
        switch(cellCornerMarks.length) {
            case 1:
                if(String(removedPosition) === cornerPositions.TOP_LEFT) {
                    shiftCornerMark(cell, cornerPositions.TOP_RIGHT, cornerPositions.TOP_LEFT);
                }
                break;
            case 2:
                if(String(removedPosition) != cornerPositions.BOTTOM_LEFT) {
                    if(String(removedPosition) === cornerPositions.TOP_LEFT) {
                        shiftCornerMark(cell, cornerPositions.TOP_RIGHT, cornerPositions.TOP_LEFT);
                    }
                    shiftCornerMark(cell, cornerPositions.BOTTOM_LEFT, cornerPositions.TOP_RIGHT);
                }
                break;
            case 3:
                if(String(removedPosition) != cornerPositions.BOTTOM_RIGHT) {
                    if(String(removedPosition) === cornerPositions.TOP_LEFT) {
                        shiftCornerMark(cell, cornerPositions.TOP_RIGHT, cornerPositions.TOP_LEFT);
                        shiftCornerMark(cell, cornerPositions.BOTTOM_LEFT, cornerPositions.TOP_RIGHT);
                    } else if(String(removedPosition) === cornerPositions.TOP_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_LEFT, cornerPositions.TOP_RIGHT);
                    }
                    shiftCornerMark(cell, cornerPositions.BOTTOM_RIGHT, cornerPositions.BOTTOM_LEFT);
                }
                break;
            case 4:
                if(String(removedPosition) != cornerPositions.MIDDLE_LEFT) {
                    if(String(removedPosition) === cornerPositions.TOP_LEFT) {
                        shiftCornerMark(cell, cornerPositions.TOP_RIGHT, cornerPositions.TOP_LEFT);
                        shiftCornerMark(cell, cornerPositions.BOTTOM_LEFT, cornerPositions.TOP_RIGHT);
                        shiftCornerMark(cell, cornerPositions.BOTTOM_RIGHT, cornerPositions.BOTTOM_LEFT);
                    } else if(String(removedPosition) === cornerPositions.TOP_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_LEFT, cornerPositions.TOP_RIGHT);
                        shiftCornerMark(cell, cornerPositions.BOTTOM_RIGHT, cornerPositions.BOTTOM_LEFT);
                    } else if(String(removedPosition) === cornerPositions.BOTTOM_LEFT) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_RIGHT, cornerPositions.BOTTOM_LEFT);
                    }
                    shiftCornerMark(cell, cornerPositions.MIDDLE_LEFT, cornerPositions.BOTTOM_RIGHT);
                }
                break;
            case 5:
                if(String(removedPosition) != cornerPositions.MIDDLE_RIGHT) {
                    if(String(removedPosition) === cornerPositions.TOP_LEFT) {
                        shiftCornerMark(cell, cornerPositions.TOP_RIGHT, cornerPositions.TOP_LEFT);
                        shiftCornerMark(cell, cornerPositions.BOTTOM_LEFT, cornerPositions.TOP_RIGHT);
                        shiftCornerMark(cell, cornerPositions.BOTTOM_RIGHT, cornerPositions.BOTTOM_LEFT);
                        shiftCornerMark(cell, cornerPositions.MIDDLE_LEFT, cornerPositions.BOTTOM_RIGHT);
                    } else if(String(removedPosition) === cornerPositions.TOP_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_LEFT, cornerPositions.TOP_RIGHT);
                        shiftCornerMark(cell, cornerPositions.BOTTOM_RIGHT, cornerPositions.BOTTOM_LEFT);
                        shiftCornerMark(cell, cornerPositions.MIDDLE_LEFT, cornerPositions.BOTTOM_RIGHT);
                    } else if(String(removedPosition) === cornerPositions.BOTTOM_LEFT) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_RIGHT, cornerPositions.BOTTOM_LEFT);
                        shiftCornerMark(cell, cornerPositions.MIDDLE_LEFT, cornerPositions.BOTTOM_RIGHT);
                    } else if(String(removedPosition) === cornerPositions.BOTTOM_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.MIDDLE_LEFT, cornerPositions.BOTTOM_RIGHT);
                    }
                    shiftCornerMark(cell, cornerPositions.MIDDLE_RIGHT, cornerPositions.MIDDLE_LEFT);
                }
                break;
            case 6:
                if(String(removedPosition) != cornerPositions.TOP_MIDDLE) {
                    if(String(removedPosition) === cornerPositions.TOP_LEFT) {
                        shiftCornerMark(cell, cornerPositions.TOP_MIDDLE, cornerPositions.TOP_LEFT);
                    } else if(String(removedPosition) === cornerPositions.TOP_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.TOP_MIDDLE, cornerPositions.TOP_RIGHT);
                    } else if(String(removedPosition) === cornerPositions.MIDDLE_LEFT) {
                        shiftCornerMark(cell, cornerPositions.TOP_MIDDLE, cornerPositions.MIDDLE_LEFT);
                    } else if(String(removedPosition) === cornerPositions.MIDDLE_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.TOP_MIDDLE, cornerPositions.MIDDLE_RIGHT);
                    } else if(String(removedPosition) === cornerPositions.BOTTOM_LEFT) {
                        shiftCornerMark(cell, cornerPositions.TOP_MIDDLE, cornerPositions.BOTTOM_LEFT);
                    } else if(String(removedPosition) === cornerPositions.BOTTOM_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.TOP_MIDDLE, cornerPositions.BOTTOM_RIGHT);
                    }
                }
                break;
            case 7:
                if(String(removedPosition) != cornerPositions.BOTTOM_MIDDLE) {
                    if(String(removedPosition) === cornerPositions.TOP_LEFT) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_MIDDLE, cornerPositions.TOP_LEFT);
                    } else if(String(removedPosition) === cornerPositions.TOP_MIDDLE) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_MIDDLE, cornerPositions.TOP_MIDDLE);
                    } else if(String(removedPosition) === cornerPositions.TOP_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_MIDDLE, cornerPositions.TOP_RIGHT);
                    } else if(String(removedPosition) === cornerPositions.MIDDLE_LEFT) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_MIDDLE, cornerPositions.MIDDLE_LEFT);
                    } else if(String(removedPosition) === cornerPositions.MIDDLE_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_MIDDLE, cornerPositions.MIDDLE_RIGHT);
                    } else if(String(removedPosition) === cornerPositions.BOTTOM_LEFT) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_MIDDLE, cornerPositions.BOTTOM_LEFT);
                    } else if(String(removedPosition) === cornerPositions.BOTTOM_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.BOTTOM_MIDDLE, cornerPositions.BOTTOM_RIGHT);
                    }
                }
                
                break;
            case 8:
                if(String(removedPosition) != cornerPositions.MIDDLE_MIDDLE) {
                    if(String(removedPosition) === cornerPositions.TOP_LEFT) {
                        shiftCornerMark(cell, cornerPositions.MIDDLE_MIDDLE, cornerPositions.TOP_LEFT);
                    } else if(String(removedPosition) === cornerPositions.TOP_MIDDLE) {
                        shiftCornerMark(cell, cornerPositions.MIDDLE_MIDDLE, cornerPositions.TOP_MIDDLE);
                    } else if(String(removedPosition) === cornerPositions.TOP_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.MIDDLE_MIDDLE, cornerPositions.TOP_RIGHT);
                    } else if(String(removedPosition) === cornerPositions.BOTTOM_LEFT) {
                        shiftCornerMark(cell, cornerPositions.MIDDLE_MIDDLE, cornerPositions.BOTTOM_LEFT);
                    } else if(String(removedPosition) === cornerPositions.BOTTOM_MIDDLE) {
                        shiftCornerMark(cell, cornerPositions.MIDDLE_MIDDLE, cornerPositions.BOTTOM_MIDDLE);
                    } else if(String(removedPosition) === cornerPositions.BOTTOM_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.MIDDLE_MIDDLE, cornerPositions.BOTTOM_RIGHT);
                    } else if(String(removedPosition) === cornerPositions.MIDDLE_LEFT) {
                        shiftCornerMark(cell, cornerPositions.MIDDLE_MIDDLE, cornerPositions.MIDDLE_LEFT);
                    } else if(String(removedPosition) === cornerPositions.MIDDLE_RIGHT) {
                        shiftCornerMark(cell, cornerPositions.MIDDLE_MIDDLE, cornerPositions.MIDDLE_RIGHT);
                    }
                }
                break;
        }
    }

    function getCornerMarkByID(cell, id) {
        const cellCornerMarks = cell.getElementsByClassName('corner-mark');
        for(const cornerMark of cellCornerMarks) {
            if(cornerMark.id === id) {
                return cornerMark;
            }
        }
        return null;
    }

    function clearCellDigit(cell) {
        const cellDigits = cell.getElementsByClassName('placed-digit');
        const cellID = parseInt(cell.id.split('-')[1]);
        while(cellDigits.length > 0) {
            cellDigits[0].remove();
            if(activeGame) {
                gameState[cellID] = '0';
                validateGrid();
            }
        }
        updateCellConfig(cell);
    }

    function updateCellConfig(cell) {
        const cellDigit = cell.getElementsByClassName('placed-digit');
        if(cellDigit.length > 0) {
            toggleCellConfigVisibility(cell, 'hidden');
        } else {
            toggleCellConfigVisibility(cell, 'visible');
        }
    }

    function toggleCellConfigVisibility(cell, visibility) {
        const cellCornerMarks = cell.getElementsByClassName('corner-mark');
        if(cellCornerMarks.length > 0) {
            for(const cornerMark of cellCornerMarks) {
                cornerMark.setAttribute('visibility', visibility)
            }
        }
        const cellMiddleMarks = cell.getElementsByClassName('middle-marks');
        if(cellMiddleMarks.length > 0) {
            for(const middleMark of cellMiddleMarks) {
                middleMark.setAttribute('visibility', visibility)
            }
        }
        const cellColors = cell.getElementsByClassName('color-segment');
        if(cellColors.length > 0) {
            for(const colorSegment of cellColors) {
                colorSegment.setAttribute('visibility', visibility)
            }
        }
    }

    function clearCellCornerMarks(cell) {
        const cellCornerMarks = cell.getElementsByClassName('corner-mark');
        while(cellCornerMarks.length > 0) {
            cellCornerMarks[0].remove();
        }
    }

    function clearSelectedCells(addToHistory) {
        const selectedCells = getSelectedCells();
        if(addToHistory) {
            updateHistory(historyActions.CLEAR_CELLS, getSelectedCellsConfigurations());
        }
        for(const cell of selectedCells) {
            if(currentMode === modes.CREATE && cell.getElementsByClassName('given-digit').length > 0) {
                cell.getElementsByClassName('given-digit')[0].remove();
            } else {
                if(currentMode === modes.COLOR && cell.getElementsByClassName('color-segment').length > 0) {
                    clearCellColors(cell);
                } else if (currentMode === modes.MIDDLE && cell.getElementsByClassName('middle-marks').length > 0) {
                    clearCellMiddleMarks(cell);
                }  else if (currentMode === modes.CORNER && cell.getElementsByClassName('corner-mark').length > 0) {
                    clearCellCornerMarks(cell);
                } else {
                    if(cell.getElementsByClassName('placed-digit').length > 0) {
                            clearCellDigit(cell);
                        } else if(cell.getElementsByClassName('middle-marks').length > 0) {
                            clearCellMiddleMarks(cell);
                        } else if(cell.getElementsByClassName('corner-mark').length > 0) {
                            clearCellCornerMarks(cell);
                        } else if(cell.getElementsByClassName('color-segment').length > 0) {
                            clearCellColors(cell);
                        }
                }
            }
        }
    }

    function getSelectedCellsConfigurations(newValue) {
        const selectedCells = getSelectedCells();
        const cellConfigurations = [];
        for(const cell of selectedCells) {
            if(cell.getElementsByClassName('given-digit').length === 0) {
                const cellPlacedDigits = cell.getElementsByClassName('placed-digit');
                const cellCornerMarks = cell.getElementsByClassName('corner-mark');
                const cellMiddleMarks = cell.getElementsByTagName('tspan');
                const cellColors = cell.getElementsByClassName('color-segment');
                const cellConfiguration = {
                    cellID: cell.id,
                    placedDigits: '',
                    cornerMarks: '',
                    middleMarks: '',
                    colors: '',
                    newValue: String(newValue)
                }
                if(cellPlacedDigits.length > 0) {
                    for(const placedDigit of cellPlacedDigits) {
                        cellConfiguration.placedDigits += placedDigit.textContent;
                    }
                }
                if(cellMiddleMarks.length > 0) {
                    for(const middleMark of cellMiddleMarks) {
                        cellConfiguration.middleMarks += middleMark.textContent;
                    }
                }
                if(cellCornerMarks.length > 0) {
                    for(const cornerMark of cellCornerMarks) {
                        cellConfiguration.cornerMarks += cornerMark.textContent;
                    }
                }
                if(cellColors.length > 0) {
                    for(const colorSegment of cellColors) {
                        cellConfiguration.colors += Object.keys(colors).find(key => colors[key] === colorSegment.getAttribute('fill'));
                    }
                }
                cellConfigurations.push(JSON.stringify(cellConfiguration));
            }
        }
        return cellConfigurations;
    }

    function clearCellMiddleMarks(cell) {
        const cellMiddleMarks = cell.getElementsByClassName('middle-marks');
        if(cellMiddleMarks.length > 0) {
            cellMiddleMarks[0].remove();
        }
    }

    function getSelectedCells() {
        const selectedCellOverlays = grid.getElementsByClassName('selected-cell');
        const selectedCells = [];
        for(const selectedCellOverlay of selectedCellOverlays) {
            selectedCells.push(selectedCellOverlay.parentElement);
        }
        return selectedCells;
    }

    function deselectAll(skipCell) {
        for(const cell of cells) {
            if(cell != skipCell) {
                deselectCell(cell);
            }
        }
    }

    function deselectCell(cell) {
        if(isSelected(cell)) {
            cell.getElementsByClassName('selected-cell')[0].remove();
            setCellColorsOpacity(cell, 1);
        }
    }

    function isSelected(cell) {
        const selectionOverlay = cell.getElementsByClassName('selected-cell');
        return selectionOverlay.length > 0;
    }

    function selectCell(cell) {
        if(!isSelected(cell)) {
            const cellBackground = cell.getElementsByClassName('cell-background')[0];
            const selectionCellXpos = parseFloat(cellBackground.getAttribute('x')) + 2;
            const selectionCellYpos = parseFloat(cellBackground.getAttribute('y')) + 2;
            const selectionOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            selectionOverlay.setAttribute('class', 'selected-cell');
            selectionOverlay.setAttribute('x', selectionCellXpos);
            selectionOverlay.setAttribute('y', selectionCellYpos);
            cell.appendChild(selectionOverlay);
            setCellColorsOpacity(cell, 0.65);
            lastCellSelection = cell;
        }
    }

    function moveCellSelection(moveDirection, shiftPressed) {
        if(lastCellSelection != null) {
            const oldCellNumber = parseInt(lastCellSelection.getAttribute('id').split('cell-')[1]);
            const oldCellRow = Math.ceil((oldCellNumber + 1) / 9);
            const oldCellColumn = (oldCellNumber - (oldCellRow * 9)) + 10;
            if(!shiftPressed || currentMode === modes.CREATE) {
                deselectAll();
            }
            switch(moveDirection) {
                case direction.UP:
                    if(oldCellRow > 1) {
                        selectCell(getCellByID('cell-' + (oldCellNumber - 9)));
                    } else {
                        selectCell(getCellByID('cell-' + (oldCellNumber + 72)));
                    }
                    break;
                case direction.DOWN:
                    if(oldCellRow < 9) {
                        selectCell(getCellByID('cell-' + (oldCellNumber + 9)));
                    } else {
                        selectCell(getCellByID('cell-' + (oldCellNumber - 72)));
                    }
                    break;
                case direction.LEFT:     
                    if(oldCellColumn > 1) {
                        selectCell(getCellByID('cell-' + (oldCellNumber - 1)));
                    } else {
                        selectCell(getCellByID('cell-' + (oldCellNumber + 8)));
                    }
                    break;
                case direction.RIGHT:
                    if(oldCellColumn < 9) {
                        selectCell(getCellByID('cell-' + (oldCellNumber + 1)));
                    } else {
                        selectCell(getCellByID('cell-' + (oldCellNumber - 8)));
                    }
                    break;
            }
        }
    }

    function getCellByID(id) {
        for(const cell of cells) {
            if(cell.getAttribute('id') === id) {
                return cell;
            }
        }
        return null;
    }

    function checkPointerIntersection(pointer, element) {
        const pointerX = pointer.x;
        const pointerY = pointer.y;
        const cellLeft = element.getBoundingClientRect().x;
        const cellRight = cellLeft + element.getBoundingClientRect().width;
        const cellTop = element.getBoundingClientRect().y;
        const cellBottom = cellTop + element.getBoundingClientRect().height;
        return (pointerX >= cellLeft && pointerX <= cellRight && pointerY >= cellTop && pointerY <= cellBottom);
    }

    function resizeGrid() {
        const game = document.getElementById('game');
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const scaleX = windowWidth / 1000;
        const scaleY = windowHeight / 1000;
        const scale = Math.min(scaleX, scaleY);
        game.style.transform = 'scale(' + scale + ')';
    }

    function encryptString(text) {
        if(text != null) return btoa(text);
        return '{}';
    }

    function decryptString(encryptedText) {
        if(encryptedText != null) return atob(encryptedText);
        return '{}';
    }

    setupGame();
    if(!activeGame && (game.dataset.importedPuzzle === 'True' && game.dataset.puzzleImportError != 'True')) {
        displayHappyMessage(happyMessages.STARTING_TIP);
    }

    window.addEventListener('resize', resizeGrid, true);
    resizeGrid();
});
</script>
<div id="game" data-imported-puzzle="{{ imported_puzzle }}" data-puzzle-job-id="{{ job_id }}" data-puzzle-title="{{ puzzle_title }}" data-puzzle-import-error="{{ import_error }}">
    <div id="header">
        <a href="/">
            <img src="{% static 'img/site-logo.svg' %}" class="site-logo">
        </a>
        <span id="puzzle-title"></span>
        <a href="#" id="cancel-puzzle-gen" class="game-control button">cancel</a>
    </div>
    <svg width="762" height="762" viewBox="0 0 762 762" fill="none" id="game-grid" xmlns="http://www.w3.org/2000/svg">
    <rect x="11" y="11" width="740" height="740" fill="#285C77" id="grid-background"/>
    <g class="cell" id="cell-0">
        <rect x="11.5" y="11.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-1">
        <rect class="cell-background" x="91.5" y="11.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-2">
        <rect  class="cell-background" x="171.5" y="11.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-3">
        <rect  class="cell-background" x="261.5" y="11.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-4">
        <rect  class="cell-background" x="341.5" y="11.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-5">
        <rect class="cell-background" x="421.5" y="11.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-6">
        <rect x="511.5" y="11.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-7">
        <rect x="591.5" y="11.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-8">
        <rect x="671.5" y="11.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-9">
        <rect class="cell-background" x="11.5" y="91.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-10">
        <rect class="cell-background" x="91.5" y="91.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-11">
        <rect  class="cell-background" x="171.5" y="91.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-12">
        <rect  class="cell-background" x="261.5" y="91.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-13">
        <rect class="cell-background" x="341.5" y="91.5" width="79" height="79"/>
    </g>
        <g class="cell" id="cell-14">
        <rect class="cell-background" x="421.5" y="91.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-15">
        <rect x="511.5" y="91.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-16">
        <rect x="591.5" y="91.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-17">
        <rect x="671.5" y="91.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-18">
        <rect class="cell-background" x="11.5" y="171.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-19">
        <rect class="cell-background" x="91.5" y="171.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-20">
        <rect  class="cell-background" x="171.5" y="171.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-21">
    <rect  class="cell-background" x="261.5" y="171.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-22">
        <rect class="cell-background" x="341.5" y="171.5" width="79" height="79"/>
    </g>
    <g class="cell" id="cell-23">
        <rect x="421.5" y="171.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-24">
        <rect x="511.5" y="171.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-25">
        <rect x="591.5" y="171.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-26">
        <rect x="671.5" y="171.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-27">
        <rect x="11.5" y="261.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-28">
        <rect x="91.5" y="261.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-29">
        <rect x="171.5" y="261.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-30">
        <rect x="261.5" y="261.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-31">
        <rect x="341.5" y="261.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-32">
        <rect x="421.5" y="261.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-33">
        <rect x="511.5" y="261.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-34">
        <rect x="591.5" y="261.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-35">
        <rect x="671.5" y="261.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-36">
        <rect x="11.5" y="341.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-37">
        <rect x="91.5" y="341.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-38">
        <rect x="171.5" y="341.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-39">
        <rect x="261.5" y="341.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-40">
        <rect x="341.5" y="341.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-41">
        <rect x="421.5" y="341.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-42">
        <rect x="511.5" y="341.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-43">
        <rect x="591.5" y="341.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-44">
        <rect x="671.5" y="341.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-45">
        <rect x="11.5" y="421.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-46">
        <rect x="91.5" y="421.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-47">
        <rect x="171.5" y="421.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-48">
        <rect x="261.5" y="421.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-49">
        <rect x="341.5" y="421.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-50">
        <rect x="421.5" y="421.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-51">
        <rect x="511.5" y="421.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-52">
        <rect x="591.5" y="421.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-53">
        <rect x="671.5" y="421.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-54">
        <rect x="11.5" y="511.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-55">
        <rect x="91.5" y="511.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-56">
        <rect x="171.5" y="511.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-57">
        <rect x="261.5" y="511.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-58">
        <rect x="341.5" y="511.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-59">
        <rect x="421.5" y="511.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-60">
        <rect x="511.5" y="511.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-61">
        <rect x="591.5" y="511.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-62">
        <rect x="671.5" y="511.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-63">
        <rect x="11.5" y="591.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-64">
        <rect x="91.5" y="591.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-65">
        <rect x="171.5" y="591.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-66">
        <rect x="261.5" y="591.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-67">
        <rect x="341.5" y="591.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-68">
        <rect x="421.5" y="591.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-69">
        <rect x="511.5" y="591.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-70">
        <rect x="591.5" y="591.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-71">
        <rect x="671.5" y="591.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-72">
        <rect x="11.5" y="671.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-73">
        <rect x="91.5" y="671.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-74">
        <rect x="171.5" y="671.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-75">
        <rect x="261.5" y="671.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-76">
        <rect x="341.5" y="671.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-77">
        <rect x="421.5" y="671.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-78">
        <rect x="511.5" y="671.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-79">
        <rect x="591.5" y="671.5" width="79" height="79" class="cell-background"/>
    </g>
    <g class="cell" id="cell-80">
    <rect x="671.5" y="671.5" width="79" height="79" class="cell-background"/>
    </g>
    <rect x="5.5" y="5.5" width="751" height="751" rx="7.5" stroke="#285C77" stroke-width="11"/>
    </svg>
    <div id="error-message"></div>
    <div id="happy-message"></div>
    <dialog id="import-dialog">
        <h4>Import Puzzle</h4>
        <form method="post">
            {% csrf_token %}
            <p>
                <label for="generate-puzzles">Generate puzzle:</label>
                <select id="puzzles-select" name="generate-puzzles">
                    <option value="gen-extreme">sudo-koo - Extreme</option>
                    <option value="gen-hard">sudo-koo - Hard</option>
                    <option value="gen-medium">sudo-koo - Medium</option>
                    <option value="gen-easy">sudo-koo - Easy</option>
                </select>
            </p>
            <div class="dialog-controls">
                <button id="import-cancel" class="dialog-secondary" type="reset">Cancel</button>
                <button id="import-submit" class="dialog-primary" type="submit">Import</button>
            </div>
        </form>
    </dialog>
    <div id="game-controls">
        <a href="#" id="digit-control" class="game-control selected" style="background: url({% static 'img/digit-control.svg' %}) center no-repeat;"></a>
        <a href="#" id="corner-control" class="game-control" style="background: url({% static 'img/corner-control.svg' %}) center bottom no-repeat;"></a>
        <a href="#" id="middle-control" class="game-control" style="background: url({% static 'img/middle-control.svg' %}) center bottom no-repeat;"></a>
        <a href="#" id="color-control" class="game-control" style="background: url({% static 'img/color-control.svg' %}) center no-repeat;"></a>
         <a href="#" id="create-button" class="game-control button">Create</a>
        <a href="#" id="import-button" class="game-control button">Import</a>
        <a href="#" id="play-button" class="game-control button primary">Play</a>
        <a href="#" id="cancel-button" class="game-control button">Cancel</a>
    </div>
</div>
{% endblock content %}